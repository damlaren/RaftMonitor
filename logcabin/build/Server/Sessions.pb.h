// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: build/Server/Sessions.proto

#ifndef PROTOBUF_build_2fServer_2fSessions_2eproto__INCLUDED
#define PROTOBUF_build_2fServer_2fSessions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "build/Protocol/Client.pb.h"
// @@protoc_insertion_point(includes)

namespace LogCabin {
namespace Server {
namespace SessionsProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_build_2fServer_2fSessions_2eproto();
void protobuf_AssignDesc_build_2fServer_2fSessions_2eproto();
void protobuf_ShutdownFile_build_2fServer_2fSessions_2eproto();

class Sessions;
class Session;
class Response;

// ===================================================================

class Sessions : public ::google::protobuf::Message {
 public:
  Sessions();
  virtual ~Sessions();

  Sessions(const Sessions& from);

  inline Sessions& operator=(const Sessions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sessions& default_instance();

  void Swap(Sessions* other);

  // implements Message ----------------------------------------------

  Sessions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sessions& from);
  void MergeFrom(const Sessions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .LogCabin.Server.SessionsProto.Session session = 1;
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::LogCabin::Server::SessionsProto::Session& session(int index) const;
  inline ::LogCabin::Server::SessionsProto::Session* mutable_session(int index);
  inline ::LogCabin::Server::SessionsProto::Session* add_session();
  inline const ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Session >&
      session() const;
  inline ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Session >*
      mutable_session();

  // @@protoc_insertion_point(class_scope:LogCabin.Server.SessionsProto.Sessions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Session > session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_build_2fServer_2fSessions_2eproto();
  friend void protobuf_AssignDesc_build_2fServer_2fSessions_2eproto();
  friend void protobuf_ShutdownFile_build_2fServer_2fSessions_2eproto();

  void InitAsDefaultInstance();
  static Sessions* default_instance_;
};
// -------------------------------------------------------------------

class Session : public ::google::protobuf::Message {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Session& default_instance();

  void Swap(Session* other);

  // implements Message ----------------------------------------------

  Session* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint64 client_id() const;
  inline void set_client_id(::google::protobuf::uint64 value);

  // required uint64 last_modified = 4;
  inline bool has_last_modified() const;
  inline void clear_last_modified();
  static const int kLastModifiedFieldNumber = 4;
  inline ::google::protobuf::uint64 last_modified() const;
  inline void set_last_modified(::google::protobuf::uint64 value);

  // required uint64 first_outstanding_rpc = 2;
  inline bool has_first_outstanding_rpc() const;
  inline void clear_first_outstanding_rpc();
  static const int kFirstOutstandingRpcFieldNumber = 2;
  inline ::google::protobuf::uint64 first_outstanding_rpc() const;
  inline void set_first_outstanding_rpc(::google::protobuf::uint64 value);

  // repeated .LogCabin.Server.SessionsProto.Response rpc_response = 3;
  inline int rpc_response_size() const;
  inline void clear_rpc_response();
  static const int kRpcResponseFieldNumber = 3;
  inline const ::LogCabin::Server::SessionsProto::Response& rpc_response(int index) const;
  inline ::LogCabin::Server::SessionsProto::Response* mutable_rpc_response(int index);
  inline ::LogCabin::Server::SessionsProto::Response* add_rpc_response();
  inline const ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Response >&
      rpc_response() const;
  inline ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Response >*
      mutable_rpc_response();

  // @@protoc_insertion_point(class_scope:LogCabin.Server.SessionsProto.Session)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_last_modified();
  inline void clear_has_last_modified();
  inline void set_has_first_outstanding_rpc();
  inline void clear_has_first_outstanding_rpc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 client_id_;
  ::google::protobuf::uint64 last_modified_;
  ::google::protobuf::uint64 first_outstanding_rpc_;
  ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Response > rpc_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_build_2fServer_2fSessions_2eproto();
  friend void protobuf_AssignDesc_build_2fServer_2fSessions_2eproto();
  friend void protobuf_ShutdownFile_build_2fServer_2fSessions_2eproto();

  void InitAsDefaultInstance();
  static Session* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 rpc_number = 1;
  inline bool has_rpc_number() const;
  inline void clear_rpc_number();
  static const int kRpcNumberFieldNumber = 1;
  inline ::google::protobuf::uint64 rpc_number() const;
  inline void set_rpc_number(::google::protobuf::uint64 value);

  // required .LogCabin.Protocol.Client.CommandResponse response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::LogCabin::Protocol::Client::CommandResponse& response() const;
  inline ::LogCabin::Protocol::Client::CommandResponse* mutable_response();
  inline ::LogCabin::Protocol::Client::CommandResponse* release_response();
  inline void set_allocated_response(::LogCabin::Protocol::Client::CommandResponse* response);

  // @@protoc_insertion_point(class_scope:LogCabin.Server.SessionsProto.Response)
 private:
  inline void set_has_rpc_number();
  inline void clear_has_rpc_number();
  inline void set_has_response();
  inline void clear_has_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 rpc_number_;
  ::LogCabin::Protocol::Client::CommandResponse* response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_build_2fServer_2fSessions_2eproto();
  friend void protobuf_AssignDesc_build_2fServer_2fSessions_2eproto();
  friend void protobuf_ShutdownFile_build_2fServer_2fSessions_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Sessions

// repeated .LogCabin.Server.SessionsProto.Session session = 1;
inline int Sessions::session_size() const {
  return session_.size();
}
inline void Sessions::clear_session() {
  session_.Clear();
}
inline const ::LogCabin::Server::SessionsProto::Session& Sessions::session(int index) const {
  return session_.Get(index);
}
inline ::LogCabin::Server::SessionsProto::Session* Sessions::mutable_session(int index) {
  return session_.Mutable(index);
}
inline ::LogCabin::Server::SessionsProto::Session* Sessions::add_session() {
  return session_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Session >&
Sessions::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Session >*
Sessions::mutable_session() {
  return &session_;
}

// -------------------------------------------------------------------

// Session

// required uint64 client_id = 1;
inline bool Session::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Session::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Session::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Session::clear_client_id() {
  client_id_ = GOOGLE_ULONGLONG(0);
  clear_has_client_id();
}
inline ::google::protobuf::uint64 Session::client_id() const {
  return client_id_;
}
inline void Session::set_client_id(::google::protobuf::uint64 value) {
  set_has_client_id();
  client_id_ = value;
}

// required uint64 last_modified = 4;
inline bool Session::has_last_modified() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Session::set_has_last_modified() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Session::clear_has_last_modified() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Session::clear_last_modified() {
  last_modified_ = GOOGLE_ULONGLONG(0);
  clear_has_last_modified();
}
inline ::google::protobuf::uint64 Session::last_modified() const {
  return last_modified_;
}
inline void Session::set_last_modified(::google::protobuf::uint64 value) {
  set_has_last_modified();
  last_modified_ = value;
}

// required uint64 first_outstanding_rpc = 2;
inline bool Session::has_first_outstanding_rpc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Session::set_has_first_outstanding_rpc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Session::clear_has_first_outstanding_rpc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Session::clear_first_outstanding_rpc() {
  first_outstanding_rpc_ = GOOGLE_ULONGLONG(0);
  clear_has_first_outstanding_rpc();
}
inline ::google::protobuf::uint64 Session::first_outstanding_rpc() const {
  return first_outstanding_rpc_;
}
inline void Session::set_first_outstanding_rpc(::google::protobuf::uint64 value) {
  set_has_first_outstanding_rpc();
  first_outstanding_rpc_ = value;
}

// repeated .LogCabin.Server.SessionsProto.Response rpc_response = 3;
inline int Session::rpc_response_size() const {
  return rpc_response_.size();
}
inline void Session::clear_rpc_response() {
  rpc_response_.Clear();
}
inline const ::LogCabin::Server::SessionsProto::Response& Session::rpc_response(int index) const {
  return rpc_response_.Get(index);
}
inline ::LogCabin::Server::SessionsProto::Response* Session::mutable_rpc_response(int index) {
  return rpc_response_.Mutable(index);
}
inline ::LogCabin::Server::SessionsProto::Response* Session::add_rpc_response() {
  return rpc_response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Response >&
Session::rpc_response() const {
  return rpc_response_;
}
inline ::google::protobuf::RepeatedPtrField< ::LogCabin::Server::SessionsProto::Response >*
Session::mutable_rpc_response() {
  return &rpc_response_;
}

// -------------------------------------------------------------------

// Response

// required uint64 rpc_number = 1;
inline bool Response::has_rpc_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_rpc_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_rpc_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_rpc_number() {
  rpc_number_ = GOOGLE_ULONGLONG(0);
  clear_has_rpc_number();
}
inline ::google::protobuf::uint64 Response::rpc_number() const {
  return rpc_number_;
}
inline void Response::set_rpc_number(::google::protobuf::uint64 value) {
  set_has_rpc_number();
  rpc_number_ = value;
}

// required .LogCabin.Protocol.Client.CommandResponse response = 2;
inline bool Response::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_response() {
  if (response_ != NULL) response_->::LogCabin::Protocol::Client::CommandResponse::Clear();
  clear_has_response();
}
inline const ::LogCabin::Protocol::Client::CommandResponse& Response::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::LogCabin::Protocol::Client::CommandResponse* Response::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::LogCabin::Protocol::Client::CommandResponse;
  return response_;
}
inline ::LogCabin::Protocol::Client::CommandResponse* Response::release_response() {
  clear_has_response();
  ::LogCabin::Protocol::Client::CommandResponse* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Response::set_allocated_response(::LogCabin::Protocol::Client::CommandResponse* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SessionsProto
}  // namespace Server
}  // namespace LogCabin

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_build_2fServer_2fSessions_2eproto__INCLUDED
